AWSTemplateFormatVersion: '2010-09-09'
Description: Phoenix service stack (dev :- single EC2, prod :- ALB + ASG + API Gateway)

Parameters:
  EnvironmentMode:
    Type: String
    AllowedValues: [development, production]
    Default: development

  VpcId:
    Type: AWS::EC2::VPC::Id

  InstanceType:
    Type: String
    Default: t4g.small

  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Optional SSH access (SSM preferred)

  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-arm64-gp2

  PublicSubnetIds:
    Type: CommaDelimitedList
    Default: ""

  PrivateSubnetIds:
    Type: CommaDelimitedList
    Default: ""

  InternetGatewayId:
    Type: String
    Default: "NONE"

  DeploymentId:
    Type: String
    Default: "initial"

  PublicSubnetCidr1: { Type: String, Default: 10.0.1.0/24 }
  PublicSubnetCidr2: { Type: String, Default: 10.0.2.0/24 }
  PrivateSubnetCidr1: { Type: String, Default: 10.0.10.0/24 }
  PrivateSubnetCidr2: { Type: String, Default: 10.0.11.0/24 }

  PhoenixServiceRepoName: { Type: String, Default: phoenix-service }
  PhoenixUiRepoName: { Type: String, Default: phoenix-ui }
  CreateALB: { Type: String, Default: "false" }
  CreatePublicRoute: { Type: String, Default: "true" }

Conditions:
  IsProd: !Equals [!Ref EnvironmentMode, production]
  UseALB: !Or [!Condition IsProd, !Equals [!Ref CreateALB, "true"]]
  NotUseALB: !Not [!Condition UseALB]
  
  CreatePublicSubnets: !Equals [!Join ["", !Ref PublicSubnetIds], ""]
  CreatePrivateSubnets: !Equals [!Join ["", !Ref PrivateSubnetIds], ""]
  
  CreatePublicSubnet2: !And [!Condition CreatePublicSubnets, !Condition UseALB]
  CreateIGW: !Equals [!Ref InternetGatewayId, "NONE"]
  NotCreateIGW: !Not [!Condition CreateIGW]
  ObservabilityWithALB: !And [!Condition IsProd, !Condition UseALB]

Resources:

  ########################
  # Networking
  ########################

  GeneratedIGW:
    Condition: CreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags: [{ Key: Name, Value: phoenix-igw }]

  VPCGatewayAttachment:
    Condition: CreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VpcId
      InternetGatewayId: !Ref GeneratedIGW

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VpcId
      Tags: [{ Key: Name, Value: phoenix-public-rt }]

  PublicRouteNewIGW:
    Condition: CreateIGW
    Type: AWS::EC2::Route
    # Explicitly wait for the attachment to ensure the VPC is ready for the route
    DependsOn: [VPCGatewayAttachment, PublicRouteTable]
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref GeneratedIGW

  PublicRouteExistingIGW:
    Condition: NotCreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::Route
    DependsOn: [PublicRouteTable]
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGatewayId

  PublicSubnet1:
    Condition: CreatePublicSubnets
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PublicSubnetCidr1
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-public-1 }]

  PublicSubnet1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !If [CreatePublicSubnets, !Ref PublicSubnet1, !Select [0, !Ref PublicSubnetIds]]
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2:
    Condition: CreatePublicSubnet2
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PublicSubnetCidr2
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [1, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-public-2 }]

  PublicSubnet2Association:
    Condition: CreatePublicSubnet2
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  PrivateSubnet1:
    Condition: CreatePrivateSubnets
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PrivateSubnetCidr1
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-private-1 }]

  PrivateSubnet2:
    Condition: CreatePrivateSubnets
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PrivateSubnetCidr2
      AvailabilityZone: !Select [1, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-private-2 }]

  ########################
  # IAM
  ########################

  PhoenixInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement: [{ Effect: Allow, Principal: { Service: ec2.amazonaws.com }, Action: sts:AssumeRole }]
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags: [{ Key: project, Value: phoenix }]

  PhoenixInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [!Ref PhoenixInstanceRole]


  PhoenixLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: !If [IsProd, Retain, Delete]
    UpdateReplacePolicy: !If [IsProd, Retain, Delete]
    Properties:
      LogGroupName: !Sub "/aws/phoenix/${AWS::StackName}"
      RetentionInDays: 3

  ########################
  # Security Groups
  ########################

  ALBSecurityGroup:
    Condition: UseALB
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Public ALB access
      SecurityGroupIngress:
        - { IpProtocol: tcp, FromPort: 80, ToPort: 80, CidrIp: 0.0.0.0/0 }

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Phoenix instance group
      SecurityGroupIngress:
        # SSH always allowed (SSM preferred)
        - { IpProtocol: tcp, FromPort: 22, ToPort: 22, CidrIp: 0.0.0.0/0 }
        # Frontend, Backend, Grafana, Jaeger restricted to ALB if present
        - { IpProtocol: tcp, FromPort: 5173, ToPort: 5173,
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
        - { IpProtocol: tcp, FromPort: 8080, ToPort: 8080, 
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
        - !If 
          - IsProd
          - { IpProtocol: tcp, FromPort: 3000, ToPort: 3000, 
              CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
              SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
          - !Ref "AWS::NoValue"
        - !If 
          - IsProd
          - { IpProtocol: tcp, FromPort: 16686, ToPort: 16686, 
              CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
              SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
          - !Ref "AWS::NoValue"
      SecurityGroupEgress:
        - { IpProtocol: -1, CidrIp: 0.0.0.0/0 }

  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Allow Postgres access from App
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref InstanceSecurityGroup

  ########################
  # RDS Resources
  ########################

  PhoenixDBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Phoenix DB Subnets
      SubnetIds: !If [CreatePrivateSubnets, [!Ref PrivateSubnet1, !Ref PrivateSubnet2], !Ref PrivateSubnetIds]

  PhoenixDBParamGroup:
    Type: AWS::RDS::DBParameterGroup
    Properties:
      Description: "Phoenix DB Param Group - logical replication + small instance tuning"
      Family: postgres16
      Parameters:
        rds.logical_replication: 1      # Required for Debezium/CDC
        shared_buffers: 268435456       # 256MB in bytes. Cache memory for small instances
        work_mem: 4194304              # 4MB in bytes. Memory per query operation
        maintenance_work_mem: 16777216  # 16MB in bytes. Memory for maintenance operations (vacuum, index rebuild)
        max_connections: 20             # Keep connections reasonable for micro instance
        effective_cache_size: 536870912       # 512MB in bytes. Helps PostgreSQL planner estimate available cache
        wal_buffers:  -1           # WAL write buffer size. Postgres auto-tunes it very well so just setting to -1.
        #synchronous_commit: on          # Ensure data durability
        checkpoint_completion_target: 0.7 # Smooth out writes
        log_min_duration_statement: 2000 # Log queries longer than 2s for dev monitoring


  PhoenixRDS:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: !If [IsProd, Snapshot, Delete]
    UpdateReplacePolicy: !If [IsProd, Snapshot, Delete]
    Properties:
      DBInstanceIdentifier: !Sub "phoenix-db-${DeploymentId}"
      Engine: postgres
      EngineVersion: "16.3"
      DBInstanceClass: db.t4g.micro   # Faster than t3.micro and Free Tier eligible in many regions
      AllocatedStorage: 20             # Minimum free-tier-friendly storage
      StorageType: gp3                  # Low-latency, free-tier-friendly
      StorageEncrypted: true            # Optional: security best practice
      DBName: insurance_corp
      MasterUsername: postgres
      MasterUserPassword: postgres      # In prod, use Secrets Manager
      VPCSecurityGroups: [!Ref RDSSecurityGroup]
      DBSubnetGroupName: !Ref PhoenixDBSubnetGroup
      DBParameterGroupName: !Ref PhoenixDBParamGroup
      PubliclyAccessible: false
      MultiAZ: false
      AvailabilityZone: !Select [0, !GetAZs ""]
      BackupRetentionPeriod: 1          # Minimal retention for CDC/WAL
      MonitoringInterval: 0            # Disabled monitoring for now. Enable Enhanced Monitoring every 60s
      EnablePerformanceInsights: true   # Useful for tuning queries
      PerformanceInsightsRetentionPeriod: 7 # Retain PI metrics for a week


  # RdsMonitoringRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Principal:
  #             Service: monitoring.rds.amazonaws.com
  #           Action: sts:AssumeRole
  #     ManagedPolicyArns:
  #       - arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole

  ########################
  # Launch Template
  ########################

  PhoenixLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: [PhoenixLogGroup, PhoenixRDS]
    Properties:
      LaunchTemplateData:
        ImageId: !Ref LatestAmiId
        InstanceType: !Ref InstanceType
        IamInstanceProfile: { Name: !Ref PhoenixInstanceProfile }
        KeyName: !Ref KeyName
        SecurityGroupIds: [ !Ref InstanceSecurityGroup ]
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: 29
              VolumeType: gp3
              DeleteOnTermination: true
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: optional
          HttpPutResponseHopLimit: 2
        TagSpecifications:
          - ResourceType: instance
            Tags: [{ Key: project, Value: phoenix }, { Key: deployment-id, Value: !Ref DeploymentId }]
        UserData:
          Fn::Base64: !Sub 
            - |
              #!/bin/bash -xe
              set -e
              exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
              echo "Starting Phoenix Bootstrap (DeploymentId: ${DeploymentId})..."
              yum update -y
              yum install -y git jq
              yum install -y git jq

              # Enable the correct Amazon Linux extras repo for PostgreSQL 14
              amazon-linux-extras enable postgresql14
              yum install -y postgresql
              psql --version


              amazon-linux-extras install docker -y
              
              # Liimt local logs to < 1GB total
              cat > /etc/docker/daemon.json <<EOF
              {
                "log-driver": "json-file",
                "log-opts": {
                  "max-size": "20m", 
                  "max-file": "5"
                }
              }
              EOF
              
              systemctl enable --now docker
              for i in {1..10}; do [ -S /var/run/docker.sock ] && break || sleep 2; done
              
              if [ ! -f /swapfile ]; then
                dd if=/dev/zero of=/swapfile bs=1G count=12
                chmod 600 /swapfile
                mkswap /swapfile
                swapon /swapfile
                echo '/swapfile none swap sw 0 0' >> /etc/fstab
              fi
              
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/bin/docker-compose
              chmod +x /usr/bin/docker-compose
              usermod -a -G docker ec2-user
              
              ACCOUNT_ID=${AWS::AccountId}
              REGION=${AWS::Region}
              ECR_REPO_URI="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/${PhoenixServiceRepoName}"
              ECR_UI_URI="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/${PhoenixUiRepoName}"
              
              aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com || true
              
              cd /opt
              [ -d "phoenix" ] || git clone https://github.com/primusa/phoenix.git
              cd phoenix
              git pull
              docker system prune -af
              docker pull $ECR_REPO_URI:latest || true
              docker pull $ECR_UI_URI:latest || true
              
              export PHOENIX_ECR_URI="$ECR_REPO_URI"
              export PHOENIX_UI_ECR_URI="$ECR_UI_URI"
              
              # RDS Connection Info
              export DB_HOST="${PhoenixRDS.Endpoint.Address}"
              export DB_PORT="${PhoenixRDS.Endpoint.Port}"
              export DB_USER="postgres"
              export DB_PASS="postgres"
              export DB_NAME="insurance_corp"
              
              cat > docker-compose-override.yml <<EOF
              services:
                phoenix-backend:
                  image: ${!PHOENIX_ECR_URI}:latest
                  environment:
                    SPRING_DATASOURCE_URL: jdbc:postgresql://${!DB_HOST}:${!DB_PORT}/${!DB_NAME}
                    SPRING_DATASOURCE_USERNAME: ${!DB_USER}
                    SPRING_DATASOURCE_PASSWORD: ${!DB_PASS}
                    MANAGEMENT_OPENTELEMETRY_LOGGING_EXPORT_ENABLED: "${OTelEnabled}"
                    MANAGEMENT_OPENTELEMETRY_TRACING_EXPORT_ENABLED: "${OTelEnabled}"
                    MANAGEMENT_OPENTELEMETRY_METRICS_EXPORT_ENABLED: "${OTelEnabled}"
                    MANAGEMENT_TRACING_SAMPLING_PROBABILITY: "${OTelSampleRate}"
                  logging:
                    driver: awslogs
                    options:
                      awslogs-region: ${AWS::Region}
                      awslogs-group: ${PhoenixLogGroup}
                      awslogs-stream: backend
                phoenix-frontend:
                  image: ${!PHOENIX_UI_ECR_URI}:latest
                  logging:
                    driver: awslogs
                    options:
                      awslogs-region: ${AWS::Region}
                      awslogs-group: ${PhoenixLogGroup}
                      awslogs-stream: frontend
                ollama:
                  logging:
                    driver: awslogs
                    options:
                      awslogs-region: ${AWS::Region}
                      awslogs-group: ${PhoenixLogGroup}
                      awslogs-stream: ollama
                otel-collector:
                  volumes:
                    - ./otel-collector-config-aws.yaml:/etc/otel-collector-config.yaml
                  logging:
                    driver: awslogs
                    options:
                      awslogs-region: ${AWS::Region}
                      awslogs-group: ${PhoenixLogGroup}
                      awslogs-stream: otel
              EOF

              PROFILES="aws"
              if [ "${EnvironmentMode}" == "production" ]; then
                PROFILES="aws,observability"
              fi
              /usr/bin/docker-compose -f docker-compose.yml -f docker-compose-override.yml --profile $PROFILES up -d
              chown -R ec2-user:ec2-user /opt/phoenix
              chown -R ec2-user:ec2-user /opt/phoenix
              
              echo "Initializing Database..."
              bash ./scripts/init-db-rds.sh || true

              
              echo "Setting up connect-debezium..."
              # Adjust setup-debezium.sh logic inline or create new
              cat > setup-debezium-rds.sh <<EOF_DEBEZIUM
              #!/bin/bash
              echo "Waiting for Debezium..."
              until curl -s -f -m 5 -o /dev/null http://localhost:8083; do
                sleep 2
              done
              
              # Wait for App to likely have created the table (or just rely on Debezium retries/errors until table exists)
              # A small sleep to give Spring Boot a head start
              sleep 15
              
              echo "Registering RDS connector..."
              curl -i -X POST -H "Accept:application/json" -H "Content-Type:application/json" \
                http://localhost:8083/connectors/ -d '{
                "name": "insurance-connector",
                "config": {
                  "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
                  "database.hostname": "'"\$DB_HOST"'",
                  "database.port": "'"\$DB_PORT"'",
                  "database.user": "'"\$DB_USER"'",
                  "database.password": "'"\$DB_PASS"'",
                  "database.dbname": "'"\$DB_NAME"'",
                  "topic.prefix": "legacy",
                  "table.include.list": "public.claims",
                  "plugin.name": "pgoutput",
                  "slot.name": "insurance_slot",
                  "publication.autocreate.mode": "filtered",
                  "snapshot.mode": "initial"
                }
              }'
              EOF_DEBEZIUM
              chmod +x setup-debezium-rds.sh
              ./setup-debezium-rds.sh || true
              
              sleep 10
              /usr/bin/docker-compose ps
            - OTelEnabled: !If [IsProd, "true", "false"]
              OTelSampleRate: !If [IsProd, "1.0", "0.0"]

  ########################
  # EC2 / ASG / ALB
  ########################

  PhoenixInstance:
    Condition: NotUseALB
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref PhoenixLaunchTemplate
        Version: !GetAtt PhoenixLaunchTemplate.LatestVersionNumber
      SubnetId: !If [CreatePublicSubnets, !Ref PublicSubnet1, !Select [0, !Ref PublicSubnetIds]]
      Tags:
        - Key: project
          Value: phoenix
        - Key: Name
          Value: phoenix-instance
        - Key: DeletionOrderDependency
          Value: !If [CreatePublicSubnets, !Join ["-", [!Ref PublicSubnet1Association, !If [CreateIGW, !Ref PublicRouteNewIGW, !Ref PublicRouteExistingIGW]]], "ExternalSubnet"]

  PhoenixLoadBalancer:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      Type: application
      Subnets: !If [CreatePublicSubnets, [!Ref PublicSubnet1, !Ref PublicSubnet2], !Ref PublicSubnetIds]
      SecurityGroups: [!Ref ALBSecurityGroup]

  FrontendTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 5173
      Protocol: HTTP

  BackendTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 8080
      Protocol: HTTP

  MonitoringTargetGroup:
    Condition: ObservabilityWithALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 3000
      Protocol: HTTP

  JaegerTargetGroup:
    Condition: ObservabilityWithALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 16686
      Protocol: HTTP


  PhoenixListener:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref PhoenixLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions: [{ Type: forward, TargetGroupArn: !Ref FrontendTargetGroup }]

  AssetsRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 5
      Actions: [{ Type: forward, TargetGroupArn: !Ref FrontendTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/assets/*]

  ApiRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 10
      Actions: [{ Type: forward, TargetGroupArn: !Ref BackendTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/api/*]

  GrafanaRule:
    Condition: ObservabilityWithALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 20
      Actions: [{ Type: forward, TargetGroupArn: !Ref MonitoringTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/grafana*]

  JaegerRule:
    Condition: ObservabilityWithALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 30
      Actions: [{ Type: forward, TargetGroupArn: !Ref JaegerTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/jaeger*]



  PhoenixAutoScalingGroup:
    Condition: UseALB
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !If [IsProd, !If [CreatePrivateSubnets, [!Ref PrivateSubnet1], !Ref PrivateSubnetIds], !If [CreatePublicSubnets, [!Ref PublicSubnet1], !Ref PublicSubnetIds]]
      LaunchTemplate:
        LaunchTemplateId: !Ref PhoenixLaunchTemplate
        Version: !GetAtt PhoenixLaunchTemplate.LatestVersionNumber
      MinSize: '1'
      MaxSize: '1'
      DesiredCapacity: '1'
      TargetGroupARNs: 
        - !Ref FrontendTargetGroup
        - !Ref BackendTargetGroup
        - !If [IsProd, !Ref MonitoringTargetGroup, !Ref "AWS::NoValue"]
        - !If [IsProd, !Ref JaegerTargetGroup, !Ref "AWS::NoValue"]
      Tags:
        - Key: project
          Value: phoenix
          PropagateAtLaunch: true
        - Key: DeletionOrderDependency
          Value: !If [CreatePublicSubnets, !Join ["-", [!Ref PublicSubnet1Association, !If [CreateIGW, !Ref PublicRouteNewIGW, !Ref PublicRouteExistingIGW]]], "ExternalSubnet"]
          PropagateAtLaunch: true

  ########################
  # API Gateway
  ########################

  PhoenixApi:
    Type: AWS::ApiGatewayV2::Api
    DeletionPolicy: !If [IsProd, Retain, Delete]
    UpdateReplacePolicy: !If [IsProd, Retain, Delete]
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      ProtocolType: HTTP

  FrontendIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/", !Sub "http://${PhoenixInstance.PublicIp}:5173/"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  AssetsIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/assets/", !Sub "http://${PhoenixInstance.PublicIp}:5173/assets/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  BackendIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/api/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:8080/api/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  GrafanaIntegration:
    Condition: IsProd
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/grafana/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:3000/grafana/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  JaegerIntegration:
    Condition: IsProd
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/jaeger/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:16686/jaeger/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY



  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "$default"
      Target: !Join ["/", ["integrations", !Ref FrontendIntegration]]

  AssetsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /assets/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref AssetsIntegration]]

  BackendRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /api/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref BackendIntegration]]



  GrafanaRoute:
    Condition: IsProd
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /grafana/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref GrafanaIntegration]]

  JaegerRoute:
    Condition: IsProd
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /jaeger/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref JaegerIntegration]]



  PhoenixApiStage:
    Type: AWS::ApiGatewayV2::Stage
    DeletionPolicy: Retain
    Properties:
      ApiId: !Ref PhoenixApi
      StageName: "$default"
      AutoDeploy: true

Outputs:
  InstanceId: { Value: !If [NotUseALB, !Ref PhoenixInstance, "ASG managed"] }
  InstancePublicIp: { Condition: NotUseALB, Value: !GetAtt PhoenixInstance.PublicIp }
  LoadBalancerDns: { Condition: UseALB, Value: !GetAtt PhoenixLoadBalancer.DNSName }
  ApiGatewayUrl:
    Description: "Stable public URL for Phoenix API"
    Value: !Sub "https://${PhoenixApi}.execute-api.${AWS::Region}.amazonaws.com/$default"
    Export:
      Name: !Sub "${AWS::StackName}-ApiGatewayUrl"
  RDSEndpoint:
    Value: !GetAtt PhoenixRDS.Endpoint.Address
