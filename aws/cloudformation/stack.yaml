AWSTemplateFormatVersion: '2010-09-09'
Description: Phoenix service stack (dev :- single EC2, prod :- ALB + ASG + API Gateway)

Parameters:
  EnvironmentMode:
    Type: String
    AllowedValues: [development, production]
    Default: development

  VpcId:
    Type: AWS::EC2::VPC::Id

  InstanceType:
    Type: String
    Default: t4g.small

  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Optional SSH access (SSM preferred)

  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-arm64-gp2

  PublicSubnetIds:
    Type: CommaDelimitedList
    Default: ""

  PrivateSubnetIds:
    Type: CommaDelimitedList
    Default: ""

  InternetGatewayId:
    Type: String
    Default: "NONE"

  DeploymentId:
    Type: String
    Default: "initial"

  PublicSubnetCidr1: { Type: String, Default: 10.0.1.0/24 }
  PublicSubnetCidr2: { Type: String, Default: 10.0.2.0/24 }
  PrivateSubnetCidr1: { Type: String, Default: 10.0.10.0/24 }

  PhoenixServiceRepoName: { Type: String, Default: phoenix-service }
  PhoenixUiRepoName: { Type: String, Default: phoenix-ui }
  CreateALB: { Type: String, Default: "false" }
  CreatePublicRoute: { Type: String, Default: "true" }

Conditions:
  IsProd: !Equals [!Ref EnvironmentMode, production]
  UseALB: !Or [!Condition IsProd, !Equals [!Ref CreateALB, "true"]]
  NotUseALB: !Not [!Condition UseALB]
  
  CreatePublicSubnets: !Equals [!Join ["", !Ref PublicSubnetIds], ""]
  CreatePrivateSubnets: !Equals [!Join ["", !Ref PrivateSubnetIds], ""]
  
  CreatePublicSubnet2: !And [!Condition CreatePublicSubnets, !Condition UseALB]
  CreateIGW: !Equals [!Ref InternetGatewayId, "NONE"]
  NotCreateIGW: !Not [!Condition CreateIGW]

Resources:

  ########################
  # Networking
  ########################

  GeneratedIGW:
    Condition: CreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags: [{ Key: Name, Value: phoenix-igw }]

  VPCGatewayAttachment:
    Condition: CreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VpcId
      InternetGatewayId: !Ref GeneratedIGW

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VpcId
      Tags: [{ Key: Name, Value: phoenix-public-rt }]

  PublicRouteNewIGW:
    Condition: CreateIGW
    Type: AWS::EC2::Route
    # Explicitly wait for the attachment to ensure the VPC is ready for the route
    DependsOn: [VPCGatewayAttachment, PublicRouteTable]
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref GeneratedIGW

  PublicRouteExistingIGW:
    Condition: NotCreateIGW
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Type: AWS::EC2::Route
    DependsOn: [PublicRouteTable]
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGatewayId

  PublicSubnet1:
    Condition: CreatePublicSubnets
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PublicSubnetCidr1
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-public-1 }]

  PublicSubnet1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !If [CreatePublicSubnets, !Ref PublicSubnet1, !Select [0, !Ref PublicSubnetIds]]
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2:
    Condition: CreatePublicSubnet2
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PublicSubnetCidr2
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [1, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-public-2 }]

  PublicSubnet2Association:
    Condition: CreatePublicSubnet2
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  PrivateSubnet1:
    Condition: CreatePrivateSubnets
    DeletionPolicy: Retain
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VpcId
      CidrBlock: !Ref PrivateSubnetCidr1
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags: [{ Key: Name, Value: phoenix-private-1 }]

  ########################
  # IAM
  ########################

  PhoenixInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement: [{ Effect: Allow, Principal: { Service: ec2.amazonaws.com }, Action: sts:AssumeRole }]
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Tags: [{ Key: project, Value: phoenix }]

  PhoenixInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [!Ref PhoenixInstanceRole]


  PhoenixLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      LogGroupName: !Sub "/aws/phoenix/${AWS::StackName}"
      RetentionInDays: 3

  ########################
  # Security Groups
  ########################

  ALBSecurityGroup:
    Condition: UseALB
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Public ALB access
      SecurityGroupIngress:
        - { IpProtocol: tcp, FromPort: 80, ToPort: 80, CidrIp: 0.0.0.0/0 }

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Phoenix instance group
      SecurityGroupIngress:
        # SSH always allowed (SSM preferred)
        - { IpProtocol: tcp, FromPort: 22, ToPort: 22, CidrIp: 0.0.0.0/0 }
        # Frontend, Backend, Grafana, Jaeger restricted to ALB if present
        - { IpProtocol: tcp, FromPort: 5173, ToPort: 5173, 
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
        - { IpProtocol: tcp, FromPort: 8080, ToPort: 8080, 
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
        - { IpProtocol: tcp, FromPort: 3000, ToPort: 3000, 
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
        - { IpProtocol: tcp, FromPort: 16686, ToPort: 16686, 
            CidrIp: !If [NotUseALB, 0.0.0.0/0, !Ref "AWS::NoValue"],
            SourceSecurityGroupId: !If [UseALB, !Ref ALBSecurityGroup, !Ref "AWS::NoValue"] }
      SecurityGroupEgress:
        - { IpProtocol: -1, CidrIp: 0.0.0.0/0 }

  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Allow Postgres access from App
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref InstanceSecurityGroup

  ########################
  # RDS Resources
  ########################

  PhoenixDBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Phoenix DB Subnets
      SubnetIds: !If [CreatePrivateSubnets, [!Ref PrivateSubnet1, !Select [0, !Ref PrivateSubnetIds]], !Ref PrivateSubnetIds]

  PhoenixDBParamGroup:
    Type: AWS::RDS::DBParameterGroup
    Properties:
      Description: Enable logical replication for Debezium
      Family: postgres16
      Parameters:
        rds.logical_replication: 1

  PhoenixRDS:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub "phoenix-db-${DeploymentId}"
      Engine: postgres
      EngineVersion: "16.3"
      DBInstanceClass: db.t4g.micro
      AllocatedStorage: 20
      StorageType: gp3
      DBName: insurance_corp
      MasterUsername: postgres
      MasterUserPassword: postgres # In prod use SecretsManager
      VPCSecurityGroups: [!Ref RDSSecurityGroup]
      DBSubnetGroupName: !Ref PhoenixDBSubnetGroup
      DBParameterGroupName: !Ref PhoenixDBParamGroup
      PubliclyAccessible: false
      MultiAZ: false
      BackupRetentionPeriod: 1 # minimal retention for CDC/WAL


  ########################
  # Launch Template
  ########################

  PhoenixLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: [PhoenixLogGroup]
    Properties:
      LaunchTemplateData:
        ImageId: !Ref LatestAmiId
        InstanceType: !Ref InstanceType
        IamInstanceProfile: { Name: !Ref PhoenixInstanceProfile }
        KeyName: !Ref KeyName
        SecurityGroupIds: [ !Ref InstanceSecurityGroup ]
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: 29
              VolumeType: gp3
              DeleteOnTermination: true
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: optional
          HttpPutResponseHopLimit: 2
        TagSpecifications:
          - ResourceType: instance
            Tags: [{ Key: project, Value: phoenix }, { Key: deployment-id, Value: !Ref DeploymentId }]
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash -xe
            set -e
            exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
            echo "Starting Phoenix Bootstrap (DeploymentId: ${DeploymentId})..."
            yum update -y
            yum install -y git jq
            yum install -y git jq
            # yum install -y postgresql # No longer needed for init
            amazon-linux-extras install docker -y
            
            # Liimt local logs to < 1GB total
            cat > /etc/docker/daemon.json <<EOF
            {
              "log-driver": "json-file",
              "log-opts": {
                "max-size": "20m", 
                "max-file": "5"
              }
            }
            EOF
            
            systemctl enable --now docker
            for i in {1..10}; do [ -S /var/run/docker.sock ] && break || sleep 2; done
            
            if [ ! -f /swapfile ]; then
              dd if=/dev/zero of=/swapfile bs=1G count=12
              chmod 600 /swapfile
              mkswap /swapfile
              swapon /swapfile
              echo '/swapfile none swap sw 0 0' >> /etc/fstab
            fi
            
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/bin/docker-compose
            chmod +x /usr/bin/docker-compose
            usermod -a -G docker ec2-user
            
            ACCOUNT_ID=${AWS::AccountId}
            REGION=${AWS::Region}
            ECR_REPO_URI="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/${PhoenixServiceRepoName}"
            ECR_UI_URI="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/${PhoenixUiRepoName}"
            
            aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com || true
            
            cd /opt
            [ -d "phoenix" ] || git clone https://github.com/primusa/phoenix.git
            cd phoenix
            git pull
            docker system prune -af
            docker pull $ECR_REPO_URI:latest || true
            docker pull $ECR_UI_URI:latest || true
            
            export PHOENIX_ECR_URI="$ECR_REPO_URI"
            export PHOENIX_UI_ECR_URI="$ECR_UI_URI"
            
            # RDS Connection Info
            export DB_HOST="${PhoenixRDS.Endpoint.Address}"
            export DB_PORT="${PhoenixRDS.Endpoint.Port}"
            export DB_USER="postgres"
            export DB_PASS="postgres"
            export DB_NAME="insurance_corp"
            
            cat > docker-compose-override.yml <<EOF
            services:
              phoenix-backend:
                image: ${!PHOENIX_ECR_URI}:latest
                environment:
                  SPRING_DATASOURCE_URL: jdbc:postgresql://${!DB_HOST}:${!DB_PORT}/${!DB_NAME}
                  SPRING_DATASOURCE_USERNAME: ${!DB_USER}
                  SPRING_DATASOURCE_PASSWORD: ${!DB_PASS}
                  MANAGEMENT_OPENTELEMETRY_LOGGING_EXPORT_ENABLED: "false"
                logging:
                  driver: awslogs
                  options:
                    awslogs-region: ${AWS::Region}
                    awslogs-group: ${PhoenixLogGroup}
                    awslogs-stream: backend
              phoenix-frontend:
                image: ${!PHOENIX_UI_ECR_URI}:latest
                logging:
                  driver: awslogs
                  options:
                    awslogs-region: ${AWS::Region}
                    awslogs-group: ${PhoenixLogGroup}
                    awslogs-stream: frontend
              ollama:
                logging:
                  driver: awslogs
                  options:
                    awslogs-region: ${AWS::Region}
                    awslogs-group: ${PhoenixLogGroup}
                    awslogs-stream: ollama
              otel-collector:
                volumes:
                  - ./otel-collector-config-aws.yaml:/etc/otel-collector-config.yaml
                logging:
                  driver: awslogs
                  options:
                    awslogs-region: ${AWS::Region}
                    awslogs-group: ${PhoenixLogGroup}
                    awslogs-stream: otel
            EOF

            /usr/bin/docker-compose -f docker-compose.yml -f docker-compose-override.yml --profile aws up -d --scale jaeger=0 --scale lgtm=0
            chown -R ec2-user:ec2-user /opt/phoenix
            chown -R ec2-user:ec2-user /opt/phoenix
            
            echo "Skipping manual DB Init (Application handles schema migration)..."
            
            echo "Setting up connect-debezium..."
            # Adjust setup-debezium.sh logic inline or create new
            cat > setup-debezium-rds.sh <<EOF_DEBEZIUM
            #!/bin/bash
            echo "Waiting for Debezium..."
            until curl -s -f -m 5 -o /dev/null http://localhost:8083; do
              sleep 2
            done
            
            # Wait for App to likely have created the table (or just rely on Debezium retries/errors until table exists)
            # A small sleep to give Spring Boot a head start
            sleep 15
            
            echo "Registering RDS connector..."
            curl -i -X POST -H "Accept:application/json" -H "Content-Type:application/json" \
              http://localhost:8083/connectors/ -d '{
              "name": "insurance-connector",
              "config": {
                "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
                "database.hostname": "'"\$DB_HOST"'",
                "database.port": "'"\$DB_PORT"'",
                "database.user": "'"\$DB_USER"'",
                "database.password": "'"\$DB_PASS"'",
                "database.dbname": "'"\$DB_NAME"'",
                "topic.prefix": "legacy",
                "table.include.list": "public.claims",
                "plugin.name": "pgoutput",
                "slot.name": "insurance_slot",
                "publication.autocreate.mode": "filtered",
                "snapshot.mode": "initial"
              }
            }'
            EOF_DEBEZIUM
            chmod +x setup-debezium-rds.sh
            ./setup-debezium-rds.sh || true
            
            sleep 10
            /usr/bin/docker-compose ps

  ########################
  # EC2 / ASG Resources
  ########################

  PhoenixInstance:
    Condition: NotUseALB
    Type: AWS::EC2::Instance
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref PhoenixLaunchTemplate
        Version: !GetAtt PhoenixLaunchTemplate.LatestVersionNumber
      SubnetId: !If [CreatePublicSubnets, !Ref PublicSubnet1, !Select [0, !Ref PublicSubnetIds]]
      Tags:
        - Key: project
          Value: phoenix
        - Key: Name
          Value: phoenix-instance
        - Key: DeletionOrderDependency
          Value: !If [CreatePublicSubnets, !Join ["-", [!Ref PublicSubnet1Association, !If [CreateIGW, !Ref PublicRouteNewIGW, !Ref PublicRouteExistingIGW]]], "ExternalSubnet"]

  PhoenixLoadBalancer:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      Type: application
      Subnets: !If [CreatePublicSubnets, [!Ref PublicSubnet1, !Ref PublicSubnet2], !Ref PublicSubnetIds]
      SecurityGroups: [!Ref ALBSecurityGroup]

  FrontendTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 5173
      Protocol: HTTP

  BackendTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 8080
      Protocol: HTTP

  MonitoringTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 3000
      Protocol: HTTP

  JaegerTargetGroup:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcId
      Port: 16686
      Protocol: HTTP

  PhoenixListener:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref PhoenixLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions: [{ Type: forward, TargetGroupArn: !Ref FrontendTargetGroup }]

  AssetsRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 5
      Actions: [{ Type: forward, TargetGroupArn: !Ref FrontendTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/assets/*]

  ApiRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 10
      Actions: [{ Type: forward, TargetGroupArn: !Ref BackendTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/api/*]

  GrafanaRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 20
      Actions: [{ Type: forward, TargetGroupArn: !Ref MonitoringTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/grafana*]

  JaegerRule:
    Condition: UseALB
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref PhoenixListener
      Priority: 30
      Actions: [{ Type: forward, TargetGroupArn: !Ref JaegerTargetGroup }]
      Conditions:
        - Field: path-pattern
          Values: [/jaeger*]

  PhoenixAutoScalingGroup:
    Condition: UseALB
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !If [IsProd, !If [CreatePrivateSubnets, [!Ref PrivateSubnet1], !Ref PrivateSubnetIds], !If [CreatePublicSubnets, [!Ref PublicSubnet1], !Ref PublicSubnetIds]]
      LaunchTemplate:
        LaunchTemplateId: !Ref PhoenixLaunchTemplate
        Version: !GetAtt PhoenixLaunchTemplate.LatestVersionNumber
      MinSize: '1'
      MaxSize: '1'
      DesiredCapacity: '1'
      TargetGroupARNs: [!Ref FrontendTargetGroup, !Ref BackendTargetGroup, !Ref MonitoringTargetGroup, !Ref JaegerTargetGroup]
      Tags:
        - Key: project
          Value: phoenix
          PropagateAtLaunch: true
        - Key: DeletionOrderDependency
          Value: !If [CreatePublicSubnets, !Join ["-", [!Ref PublicSubnet1Association, !If [CreateIGW, !Ref PublicRouteNewIGW, !Ref PublicRouteExistingIGW]]], "ExternalSubnet"]
          PropagateAtLaunch: true

  ########################
  # API Gateway
  ########################

  PhoenixApi:
    Type: AWS::ApiGatewayV2::Api
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      ProtocolType: HTTP

  FrontendIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/", !Sub "http://${PhoenixInstance.PublicIp}:5173/"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  AssetsIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/assets/", !Sub "http://${PhoenixInstance.PublicIp}:5173/assets/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  BackendIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/api/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:8080/api/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  GrafanaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/grafana/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:3000/grafana/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  JaegerIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref PhoenixApi
      IntegrationType: HTTP_PROXY
      IntegrationUri: !If [UseALB, !Sub "http://${PhoenixLoadBalancer.DNSName}/jaeger/{proxy}", !Sub "http://${PhoenixInstance.PublicIp}:16686/jaeger/{proxy}"]
      PayloadFormatVersion: "1.0"
      IntegrationMethod: ANY

  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "$default"
      Target: !Join ["/", ["integrations", !Ref FrontendIntegration]]

  AssetsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /assets/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref AssetsIntegration]]

  BackendRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /api/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref BackendIntegration]]

  GrafanaRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /grafana/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref GrafanaIntegration]]

  JaegerRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref PhoenixApi
      RouteKey: "ANY /jaeger/{proxy+}"
      Target: !Join ["/", ["integrations", !Ref JaegerIntegration]]

  PhoenixApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref PhoenixApi
      StageName: "$default"
      AutoDeploy: true

Outputs:
  InstanceId: { Value: !If [NotUseALB, !Ref PhoenixInstance, "ASG managed"] }
  InstancePublicIp: { Condition: NotUseALB, Value: !GetAtt PhoenixInstance.PublicIp }
  LoadBalancerDns: { Condition: UseALB, Value: !GetAtt PhoenixLoadBalancer.DNSName }
  ApiGatewayUrl:
    Value: !Sub "https://${PhoenixApi}.execute-api.${AWS::Region}.amazonaws.com/"
  RDSEndpoint:
    Value: !GetAtt PhoenixRDS.Endpoint.Address
